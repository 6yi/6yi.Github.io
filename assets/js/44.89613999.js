(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{535:function(t,e,n){"use strict";n.r(e);var a=n(5),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[t._v("?\t\t其实Tcp只是负责数据的传输,粘包问题并不是TCP的锅.\n"),n("p",[t._v("?\t\t那么粘包是什么呢,实际上就是数据的拆包和合并,因为在我们事先并不知道对方发送的数据包大小,所以都是来了多少数据就读多少数据,这样就会造成粘包现象,比如我发送3次,每次1个int大小,那总共就是12个byte,而实际情况可能是对方先获取到了两个int大小,或者只获取到了2个byte,剩下的byte和下面的数据一起过来了,又或者一次性被读完了3个int")]),t._v(" "),n("p",[t._v("?\t"),n("img",{attrs:{src:"http://59.110.173.180:9090/static/SavePic/f5d140f3d40875cc44a1a8f6d03aa28a微信图片_20200325193008.png"}})]),t._v(" "),n("blockquote",[n("p",[t._v("图示 数据2的前两个字节和数据1一起被读取")])]),t._v(" "),n("p",[t._v("以上这些都是粘包现象,解决这个问题的话就需要我们自定义发送协议,先发送一个数据告诉对方我接下来要发送数据的长度,你就按这个长度进行获取,这样就避免了过多或者过少获取数据")])])}),[],!1,null,null,null);e.default=s.exports}}]);